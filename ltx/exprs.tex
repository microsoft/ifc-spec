\label{sec:ifc-exprs}

Expressions are indicated by abstract expression references.
They are values of type \type{ExprIndex}, with 32-bit precision and the
following layout
\begin{figure}[htbp]
  \centering
	\absref{6}{ExprSort}
  \caption{\type{ExprIndex}: Abstract reference of expression}
  \label{fig:ifc-expr-index}
\end{figure}
%

\begin{SortEnum}{ExprSort}
	\enumerator{VendorExtension}
	\enumerator{Empty}
	\enumerator{Literal}
	\enumerator{Lambda}
	\enumerator{Type}
	\enumerator{NamedDecl}
	\enumerator{UnresolvedId}
	\enumerator{TemplateId}
	\enumerator{UnqualifiedId}
	\enumerator{SimpleIdentifier}
	\enumerator{Pointer}
	\enumerator{QualifiedName}
	\enumerator{Path}
	\enumerator{Read}
	\enumerator{Monad}
	\enumerator{Dyad}
	\enumerator{Triad}
	\enumerator{String}
	\enumerator{Temporary}
	\enumerator{Call}
	\enumerator{MemberInitializer}
	\enumerator{MemberAccess}
	\enumerator{InheritancePath}
	\enumerator{InitializerList}
	\enumerator{Cast}
	\enumerator{Condition}
	\enumerator{ExpressionList}
	\enumerator{SizeofType}
	\enumerator{Alignof}
	\enumerator{Label}
	\enumerator{Unused0}
	\enumerator{Typeid}
	\enumerator{DestructorCall}
	\enumerator{SyntaxTree}
	\enumerator{FunctionString}
	\enumerator{CompoundString}
	\enumerator{StringSequence}
	\enumerator{Initializer}
	\enumerator{Requires}
	\enumerator{UnaryFold}
	\enumerator{BinaryFold}
	\enumerator{HierarchyConversion}
	\enumerator{ProductTypeValue}
	\enumerator{SumTypeValue}
	\enumerator{SubobjectValue}
	\enumerator{ArrayValue}
	\enumerator{DynamicDispatch}
	\enumerator{VirtualFunctionConversion}
	\enumerator{Placeholder}
	\enumerator{Expansion}
	\enumerator{Generic}
	\enumerator{Tuple}
	\enumerator{Nullptr}
	\enumerator{This}
	\enumerator{TemplateReference}
	\enumerator{Statement}
	\enumerator{TypeTraitIntrinsic}
	\enumerator{DesignatedInitializer}
	\enumerator{PackedTemplateArguments}
	\enumerator{Tokens}
	\enumerator{AssignInitializer}
\end{SortEnum}


\section{Expression structures}
\label{sec:ifc-expression-structures}

\subsection{\valueTag{ExprSort::VendorExtension}}
\label{sec:ifc:ExprSort:VendorExtension}

\partition{expr.vendor-extension}

\subsection{\valueTag{ExprtSort::Empty}}
\label{sec:ifc:ExprSort:Empty}

In certain circumstances, expressions are expected but missing, e.g. an empty-pack in a template-argument list.
An \type{ExprIndex} value with tag \valueTag{ExprSort::Empty} represents a reference to an empty expression.
The \field{index} field is an index into the empty expression partition.
Each entry in that partition has two components: a \field{type} field and a \field{locus} field.
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
	}
	\caption{Structure of an empty expression}
	\label{fig:ifc-empty-expression-structure}
\end{figure}
%
The \field{type} field is a reference to the type of the expression.
The \field{locus} field is a reference to the source location.

\partition{expr.empty}

\subsection{\valueTag{ExprSort::Literal}}
\label{sec:ifc:ExprSort:Literal}

A \type{ExprIndex} value with tag \valueTag{ExprSort::Literal} represents a reference to a literal.
The \field{index} field is an index into the literal expression partition.
Each entry in that partition has three components: a \field{type} field, a \field{value} field, and a \field{locus} field.
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{value}{LitIndex} \\
	}
	\caption{Structure of a literal expression}
	\label{fig:ifc-literal-expr-structure}
\end{figure}
%
The \field{type} field represents the type of the expression.
The \field{value} field represents the value of the expression.
The \field{locus} represents the source location of the expression.

\partition{expr.literal}

\subsubsection{Literal Values}
\label{sec:ifc-literal-values}

Literal values are represented by abstract references of type \type{LitIndex}, with the following layout
%
\begin{figure}[htbp]
  \centering
	\absref{2}{LiteralSort}
  \caption{\type{LitIndex}: Abstract reference of literal constants}
  \label{fig:ifc-lit-index}
\end{figure}
%

The possible values of the \field{tag} field are described by the type \type{LiteralSort} defined as follows
\begin{typedef}{LiteralSort}{}
	enum class LiteralSort : uint8_t {
		Immediate,
		Integer,
		FloatingPoint,
	};
\end{typedef}

The meaning of these tags is as follows:
\begin{itemize}
	\item \valueTag{LiteralSort::Immediate}: The \field{value} field of the abstract reference directly holds a 32-bit unsigned integer value.
	\item \valueTag{LiteralSort::Integer}: The \field{value} field is an index into the \code{"const.i64"} partition.  The value at that entry is a 64-bit unsigned integer value.
	\item \valueTag{LiteralSort::FloatingPoint}: The \field{value} field is an index into the \code{"const.f64"} partition. 
	Each entry in that partition is a $12$-byte structure: The first $8$ bytes represent 
	a 64-bit floating point value, in IEEE 754 little endian format.  The remaining $4$ bytes have indeterminate values.
\end{itemize}

\note{This representation is subject to change in future releases.}

\subsection{\valueTag{ExprSort::Lambda}}
\label{sec:ifc:ExprSort:Lambda}

An \type{ExprIndex} value with tag \valueTag{ExprSort::Lambda} designates a lambda expression in syntactic form (\secref{sec:ifc-syntax-tree-table}).
The \field{index} field of that abstract reference is an index into the lambda expression partition.
Each entry of that partition is a structure with the following structure:
%
\begin{figure}[H]
	\centering
	\structure[text width = 15em]{
		\DeclareMember{introducer}{SyntaxIndex} \\
		\DeclareMember{template\_parameters}{SyntaxIndex} \\
		\DeclareMember{declarator}{SyntaxIndex} \\
		\DeclareMember{constraint}{SyntaxIndex} \\
		\DeclareMember{body}{SyntaxIndex} \\
	}
	\caption{Structure of a lambda expression}
	\label{fig:ifc-lambda-structure}
\end{figure}
%

The \field{introducer} field designates the syntactic element for the lambda introducer.
The \field{template\_parameters} field designates the syntactic element for any possible template parameter list.
The \field{declarator} field designates the syntactic element for the declarator part of the lambda expression.
The \field{constraint} field designates the syntactic element for the requires-clause, if any.
Finally, the \field{body} field denotes the syntactic element for the body of the lambda expression. 

\partition{expr.lambda}

\note{This representation is subject to change}



\subsection{\valueTag{ExprSort::Type}}
\label{sec:ifc:ExprSort:Type}

Certain C++ source-level contexts permit both value expressions and type expressions.
A \type{ExprIndex} value with tag \valueTag{ExprSort::Type} represents a reference to a type expression.
The \field{index} field is an index into the type expression partition.
Each entry in that partition has two components: a \field{type} field, and a \field{locus} field.
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{denotation}{TypeIndex} \\
	}
	\caption{Structure of a literal expression}
	\label{fig:ifc-type-expr-structure}
\end{figure}
%
The \field{denotation} field is a reference to the type designated by this expression structure.
The \field{locus} field is the source location.
The \field{type} field designates the sort of type, typically \code{TypeBasis::Typename}.

\partition{expr.type}


\subsection{\valueTag{ExprSort::NamedDecl}}
\label{sec:ifc:ExprSort:NamedDecl}

A \type{ExprIndex} value with tag \valueTag{ExprSort::NamedDecl} denotes the use of a name of a declaration as an expression.
The \field{index} field is an index into the named declaration expression partition.
Each entry in that partition has three components: a \field{type} field, a \field{resolution} field, and a \field{locus} field.
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{resolution}{DeclIndex} \\
	}
	\caption{Structure of use of named declaration expression}
	\label{fig:ifc-named-decl-expression-structure}
\end{figure}
%
The \field{type} field denotes the type of the expression.
The \field{resolution} field denotes the declaration the name resolved to, e.g. as indicated by the appropriate language rules.
The \field{locus} denotes the source location.

\partition{expr.decl}


\subsection{\valueTag{ExprtSort::UnresolvedId}}
\label{sec:ifc:ExprSort:UnresolvedId}

A \type{ExprIndex} value with tag \valueTag{ExprSort::UnresolveId} represents a C++ source-level dependent name, or an unresolve name.
The \field{index} field is an index into the unresolved name expression partition.
Each entry in that partition has two components: a \field{name} field, and a \field{locus} field.
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{name}{NameIndex} \\
	}
	\caption{Structure of an unresolved name expression}
	\label{fig:ifc-unresolved-name-expression-structure}
\end{figure}
%
The \field{name} field denotes the name.
The \field{locus} field denotes the source location.

\partition{expr.unresolved}

\note{This structure is subject to removal in future releases.}


\subsection{\valueTag{ExprSort::TemplateId}}
\label{sec:ifc:ExprSort:TemplateId}

A \type{ExprIndex} value with tag \valueTag{ExprSort::TemplateId} represents a reference to a template-id.
The \field{index} field is an index into the template-id expression partition.
Each entry in that partition is a structure with three components: a \field{primary} field, an \field{arguments} field, and a \field{locus} field.
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{primary}{ExprIndex} \\
		\DeclareMember{arguments}{ExprIndex} \\
	}
	\caption{Structure of a template-id expression}
	\label{fig:ifc-template-id-expression-structure}
\end{figure}
%
The \field{primary} field denotes the primary template.
The \field{arguments} field denotes the template-argument list.
If that list is empty or is a singleton, \field{arguments} denotes that template-argument directly.
Otherwise, it denotes a tuple expression.
The \field{locus} denotes the source location.

\partition{expr.template-id}


\subsection{\valueTag{ExprSort::UnqualifiedId}}
\label{sec:ifc:ExprSort:UnqualifiedId}

A \type{ExprIndex} value with tag \valueTag{ExprSort::UnqualifiedId}
 denotes the C++ grammar term \grammar{unqualified-id} or a component of \grammar{qualified-id} expression (\sortref{QualifiedName}{ExprSort}),
 some of which might
not be bound to any declaration, or might be assumed to name a template by fiat (when preceded by the \code{template} keyword).
The \field{index} field is an index into the identifier expression partition.  Each entry in that partition
is a structure with the following layout:
%
\begin{figure}[H]
	\centering
	\structure [text width = 15em]{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{name}{NameIndex} \\
		\DeclareMember{resolution}{ExprIndex} \\
		\DeclareMember{template\_keyword}{SourceLocation} \\
	}
	\caption{Structure of an identifier used to form an expression}
	\label{fig:ifc-identifier-expr-structure}
\end{figure}
%
The \field{name} denotes the name of that component in the \grammar{qualified-id} expression.
The \field{resolution} denotes the (possible set of) declaration the name refers to, if any.
The \field{template\_keyword}, if valid, designate the source location position of the \code{template} keyword.
The \field{locus} denotes the source location of this expression.

\partition{expr.unqualified-id}

\note{This structure is subject to change in future releases.}


\subsection{\valueTag{ExprSort::SimpleIdentifier}}
\label{sec:ifc:ExprSort:SimpleIdentifier}

A \type{ExprIndex} value with tag \valueTag{ExprSort::SimpleIdentifier} denotes the use of a simple name 
in a templated code.  Typically, these identifiers are used as label names.  The \field{index} field is an index
into the simple identifier partition.  Each entry in that partition is a structure with the following layout:
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{name}{NameIndex} \\
	}
	\caption{Structure of a simple-identifier expression}
	\label{fig:ifc-simple-identifier-structure}
\end{figure}
%
The \field{locus} field denotes the location of this expression.  The \field{type}, if not null, denotes the
type of the expression.  The \field{name} field designates the simple identifier.

\partition{expr.simple-identifier}

\note{This structure is subject to removal in future releases. }


\subsection{\valueTag{ExprSort::Pointer}}
\label{sec:ifc:ExprSort:Pointer}

An \type{ExprIndex} value with tag \valueTag{ExprSort::Pointer} designates the use of \code{*} in a 
\grammar{ptr-declarator} as part of the a \grammar{declarator}.  It is \emph{not} an expression.
The \field{index} field of that abstract reference designates an entry with the following layout
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
	}
	\label{fig:ifc-pointer-expr-structure}
\end{figure}
%
The \field{locus} designates the source location of the \code{*} in the input source code.

\partition{expr.pointer}

\note{This sort best belongs to the syntax tree hierarchy and has no bearing to expressions.  
It is scheduled for removal in future releases of MSVC.}

\subsection{\valueTag{ExprSort::QualifiedName}}
\label{sec:ifc:ExprSort:QualifiedName}

An \type{ExprIndex} value with tag \valueTag{ExprSort::QualifiedName} designates a representation of 
C++ input source level grammar term \grammar{qualified-id}, typically in templated code that is not
yet fully semantically analyzed.  The \field{index} field of that abstract reference is an index into
the qualified name partition.  Each entry of that partition has the following layout
%
\begin{figure}[H]
	\centering
	\structure[text width = 15em]{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{elements}{ExprIndex} \\
		\DeclareMember{typename\_keyword}{SourceLocation} \\
	}
	\caption{Structure of a qualified name expression}
	\label{fig:ifc-qualified-name-structure}
\end{figure}
%
The \field{elements} field designates the sequence of unqualified names (e.g. \sortref{UnqualifiedId}{ExprSort}, \sortref{TemplateId}{ExprSort}, etc.)
 in the source level construct.  The \field{template\_keyword}, if not null, designates the presence of
 the \code{typename} keyword in the input source program to indicate to the parser that the qualified name actually names a type.

\partition{expr.qualified-name}

\note{This structure is subject to change in future releases.}

\subsection{\valueTag{ExprSort::Path}}
\label{sec:ifc:ExprSort:Path}

A \type{ExprIndex} value with tag \valueTag{ExprSort::Path} represents
a reference to a qualified-id expression. 
The \field{index} field is an index into the path expression partition.
Each entry in that partition has three components: a \field{scope} field, a \field{member} field, and a \field{locus} field.
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{scope}{ExprIndex} \\
		\DeclareMember{member}{ExprIndex} \\
	}
	\caption{Structure of a path expression}
	\label{fig:ifc-path-expression-structure}
\end{figure}
%
The \field{scope} field denotes the qualifying part of the expression.
The \field{member} field denotes the referenced member of the \field{scope}.
The \field{locus} field denotes the source location.

\partition{expr.path}


\subsection{\valueTag{ExprSort::Read}}
\label{sec:ifc:ExprSort:Read}

A \type{ExprIndex} value with tag \valueTag{ExprSort::Read} represents
a reference to an expression that reads from a given memory location.
It is also used to represents so-called lvalue-to-rvalue conversions.
The \field{index} field is an index into the read expression partition.
Each entry in that partition has three components: a \field{type} field, an \field{address} field, and a \field{locus} field.
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{address}{ExprIndex} \\
		\DeclareMember{sort}{ReadConversionSort} \\
	}
	\caption{Structure of a read expression}
	\label{fig:ifc-read-expression-structure}
\end{figure}
%
The \field{type} field denotes the type of the expression.
The \field{address} field denotes the memory location.
The \field{locus} denotes the source location.
The \field{sort} denotes the sort of conversion performed by this expression.

\partition{expr.read}

\note{This structure is subject to change in future releases.}

\subsubsection{\type{ReadConversionSort}}
An expression that reads from a memory location can also perform an implicit conversion either on the operand,
or on the result of the read.  The sort of conversion performed is indicated by a value type \type{ReadConversionSort} defined as
\begin{typedef}{ReadConversionSort}{}
	enum class ReadConversionSort : uint8_t {
		Identity,
		Indirection,
		Dereference,
		LvalueToRvalue,
		IntegralConversion,
	};
\end{typedef}
with the following semantics
\begin{itemize}
	\item \valueTag{ReadConversionSort::Identity}: No special interpretation or conversion applied.
	\item \valueTag{ReadConversionSort::Indirection}: This is an indirection via a pointer, or via the name of an entity treated as a pointer.
	\item \valueTag{ReadConversionSort::Dereference}: The operand is a reference, and the result of the read is the address of the entity referred to.
	\item \valueTag{ReadConversionSort::LvalueToRvalue}: This expression represents an lvalue-to-rvalue conversion
	\item \valueTag{ReadConversionSort::IntegralConversion}: The result of the read operation is followed by an integral conversion.
\end{itemize}


\subsection{\valueTag{ExprtSort::Monad}}
\label{sec:ifc:ExprSort:Monad}

A \type{ExprIndex} value with tag \valueTag{ExprSort::Monad} represents the application of a (source-level) monadic operator to argument.
The \field{index} field is an index into the monadic expression partition.
Each entry in that partition is a structure with the following layout
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{impl}{DeclIndex} \\
		\DeclareMember{argument}{ExprIndex} \\
		\DeclareMember{assoc}{MonadicOperator} \\
	}
	\caption{Structure of a monadic expression}
	\label{fig:ifc-monadic-expression-structure}
\end{figure}
%
and meanings of the fields:
\begin{itemize}
	\item \field{locus} denotes the source location.
	\item \field{type} denotes the type of the expression.
	\item \field{impl}, when non-null, designates the semantic resolution of the operator denoted by \code{assoc} if it is user-defined.
	This semantic resolution can be an overload set (i.e. \valueTag{DeclSort::Tuple}) if the expression appears in a templated code,
	accounting for the set of declarations found by applicable name lookup in the template definition context.
	\item \field{argument} denotes the argument to the operator.
	\item \field{assoc} field denotes the conceptual monadic operation, usually as written in the input C++ source code, 
	\secref{sec:ifc:OperatorSort:Monadic}.
\end{itemize}

\partition{expr.monad}


\subsection{\valueTag{ExprSort::Dyad}}
\label{sec:ifc:ExprSort:Dyad}

A \type{ExprIndex} value with tag \valueTag{ExprSort::Dyad} represents the application of a (source-level) dyadic operator (\secref{sec:ifc:OperatorSort:Dyadic}) to arguments.
The \field{index} field is an index into the dyadic expression partition.
Each entry in that partition is a structure with the following layout
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{impl}{DeclIndex} \\
		\DeclareMember{arguments}{ExprIndex[2]} \\
		\DeclareMember{assoc}{DyadicOperator} \\
	}
	\caption{Structure of a dyadic expression}
	\label{fig:ifc-dyadic-expression-structure}
\end{figure}
%
and meanings of the fields:
\begin{itemize}
	\item The \field{locus} denotes the source location.
	\item The \field{type} field denotes the type of the expression.
	\item The \field{impl} field, when non-null, designates the semantic resolution of the operator denoted by \code{assoc} 
	if it is user-defined. This semantic resolution can be an overload set (\valueTag{DeclSort::Tuple}) if the expression 
	appears in a templated code, accounting for the set of declarations found by applicable name lookup in the template definition context.
	\item The \field{arguments} field denotes the two arguments to the operator.
	\item The \field{assoc} field denotes the conceptual dyadic operation, usually as written in the input C++ source code
	(\secref{sec:ifc:OperatorSort:Dyadic}).
\end{itemize}

\partition{expr.dyad}

\subsection{\valueTag{ExprSort::Triad}}
\label{sec:ifc:ExprSort:Triad}

A \type{ExprIndex} value with tag \valueTag{ExprSort::Monad} represents the application of a (source-level) triadic operator (\secref{sec:ifc:OperatorSort:Triadic}) to arguments.
The \field{index} field is an index into the triadic expression partition.
Each entry in that partition is a structure with the following layout
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{impl}{DeclIndex} \\
		\DeclareMember{arguments}{ExprIndex[3]} \\
		\DeclareMember{assoc}{TriadicOperator} \\
	}
	\caption{Structure of a triadic expression}
	\label{fig:ifc-triadic-expression-structure}
\end{figure}
%
and meaning of the fields:
\begin{itemize}
	\item \field{locus} denotes the source location.
	\item \field{type} denotes the type of the expression.
	\item \field{impl}, when non-null, designates the semantic resolution of the operator denoted by \code{assoc} if it is user-defined.
	This semantic resolution can be an overload set (\valueTag{DeclSort::Tuple}) if the expression appears in a templated code,
	accounting for the set of declarations found by applicable name lookup in the template definition context.
	\item \field{arguments} denotes the three arguments to the operator.
	\item \field{assoc} denotes the conceptual triadic operation, usually as written in the input C++ source code
	(\secref{sec:ifc:OperatorSort:Triadic}).
\end{itemize}

\partition{expr.triad}


\subsection{\valueTag{ExprSort::String}}
\label{sec:ifc:ExprSort:String}

A \type{ExprIndex} value with tag \valueTag{ExprSort::String} represents a reference to a string literal
expression.  The \field{index} field is an index into the string literal partition (not to be confused with the string table).
Each entry of that partition is a structure with the following components: a \field{string\_index} field, and a \field{locus} field.
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{string\_index}{StringIndex} \\
	}
	\caption{Structure of a string literal expression}
	\label{fig:ifc-string-literal-expression-structure}
\end{figure}
%
The \field{string\_index} field is an index into the partition of the representations of string literals.
The \field{locus} denotes the source location.

 The interpretation of each
string in that table is given by the abstract reference, a \type{StringIndex}, used to index into
the string table.  A \type{StringIndex} value, like any abstract reference, is a 32-bit value:
\begin{figure}[H]
  \centering
	\absref{3}{StringSort}
  \caption{\type{StringIndex}: Abstract reference of string constant}
  \label{fig:ifc-string-index}
\end{figure}

In its current implementation, the tag of the \type{StringIndex} is given by the following declaration
\begin{lstlisting}
  enum class StringSort : uint8_t {
     Ordinary,
     UTF8,
     Char16,
     Char32,
     Wide,
  };
\end{lstlisting}

The string table is always present, and non-empty.  It is an array of bytes, the content of which is interpreted according to the abstract reference used to index it.
The first entry is the NUL byte, therefore a \type{StringIndex} with 0 \field{tag} and 0 \field{index} represents the empty string.

\partition{expr.strings}

\subsubsection{\valueTag{StringSort::Ordinary}}
A \type{StringIndex} with tag \valueTag{StringSort::Ordinary}  represents an ordinary, narrow NUL-terminated string constant.
The \field{value} field is an index into the string table, pointing to the first byte of the string.


\subsubsection{\valueTag{StringSort::UTF8}}
A \type{StringIndex} with tag \valueTag{StringSort::UTF8}  represents a UTF-8 narrow NUL-terminated string constant. 
In terms of C++ source-level construct, it represents a string constant with \code{u8} prefix.
The \field{value} field is an index into the string table, pointing to the first byte of the string.

\subsubsection{\valueTag{StringSort::Char16}}
A \type{StringIndex} with tag \valueTag{StringSort::Char16}  represents a \code{char16_t} string constant with \code{u} prefix.
The \field{value} field is an index into the string table, pointing to the first byte of the string.


\subsubsection{\valueTag{StringSort::Char32}}
A \type{StringIndex} with tag \valueTag{StringSort::Char32}  represents a \code{char32_t} string constant with \code{u} prefix.
The \field{value} field is an index into the string table, pointing to the first byte of the string.


\subsubsection{\valueTag{StringSort::Wide}}

A \type{StringIndex} with tag \valueTag{StringSort::Wide}  represents wide string constant with only the \code{L} prefix.
The \field{value} field is an index into the string table, pointing to the first byte of the string.


\subsubsection{String literal structure}
Each entry of the partition for string literal representation is a structure with the following components:
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{start}{TextOffset} \\
		\DeclareMember{length}{Cardinality} \\
		\DeclareMember{suffix}{TextOffset} \\
	}
	\caption{Structure of a string literal}
	\label{fig:ifc-string-literal-structure}
\end{figure}
%
The \field{start} field is an index into the string table, representing the start of the string.
The \field{length} field denotes the number of bytes taken up by the string, not counting suffix, if any.
The \field{suffix} field is an index into the string table denoting the suffix, if any, of the string literal.

\partition{const.str}

\subsection{\valueTag{ExprSort::Temporary}}
\label{sec:ifc:ExprSort:Temporary}

A \type{ExprIndex} value with tag \valueTag{ExprSort::Temporary} represents a
reference to a C++ source-level expression designating a temporary object.
The \field{index} field is an index into the temporary expression partition.
Each entry in that partition is a structure with the following components: a \field{type} field, an \field{id} field, and a \field{locus} field.
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{id}{UniqueID} \\
	}
	\caption{Structure of a temporary object expression}
	\label{fig:ifc-temporary-expression-structure}
\end{figure}
%
The \field{type} field denotes the type of the expression.
The \field{id} field denotes a unique identification of the temporary object.
Its value is of type \newtype{UniqueID}{32}
The \field{locus} field denotes the source location.

\partition{expr.temporary}

\subsection{\valueTag{ExprSort::Call}}
\label{sec:ifc:ExprSort:Call}

A \type{ExprIndex} value with tag \valueTag{ExprSort::Call} represents
a reference to a call expression.
The \field{index} field is an index into the call expression partition.
Each entry in that partition is a structure with five components: a \field{type} field, an \field{operation} field, an \field{arguments} field,
a \field{locus} field, and an \field{opcat} field.
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{operation}{ExprIndex} \\
		\DeclareMember{arguments}{ExprIndex} \\
	}
	\caption{Structure of a call expression}
	\label{fig:ifc-call-expression-structure}
\end{figure}
%
The \field{type} field denotes the type of the expression.  Usually, it the return type of the function.
The \field{operation} field denotes the expression being invoked.
The \field{arguments} field denotes the list of arguments to supplied. It that list is empty or a singleton, \field{arguments} directly denotes that expression.
Otherwise it denotes a type expression.
The \field{locus} field denotes the source location.

\partition{expr.call}

\subsection{\valueTag{ExprSort::MemberInitializer}}
\label{sec:ifc:ExprSort:MemberInitializer}

An \type{ExprIndex} value with tag \valueTag{ExprSort::MemberInitializer} designates the initialization of 
a base-class subobject, or a non-static data member, or a call to a delegated constructor.  The \field{index}
field of that abstract reference is an index into the member initializer partition.  Each entry in that
partition has the following layout 
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{member}{DeclIndex} \\
		\DeclareMember{base}{TypeIndex} \\
		\DeclareMember{initializer}{ExprIndex} \\
	}
	\caption{Structure of a member-initializer expression}
	\label{fig:ifc-member-initializer-expression-structure}
\end{figure}
%
The \field{locus} field designates the source location of the member initialization.
The \field{type} field denotes the type of the initialization.
The \field{member} field, if not null, designates the non-static data member being initialized.
The \field{base} field, if not null, designates the initialization of a base-class subobject.
Both fields \field{member} and \field{base} cannot be simultaneously non-null.
However, they can be simultaneously null; in that case, the expression is used
to represent a call to a delegated constructor.
The \field{initializer} field denotes the expression performing the initialization.


\partition{expr.member-initializer}

\note{This structure is subject to change in future releases.}

\subsection{\valueTag{ExprSort::MemberAccess}}
\label{sec:ifc:ExprSort:MemberAccess}

An \type{ExprIndex} value with tag \valueTag{ExprSort::MemberAccess} designates
an access to a non-static data member of an object.  The access is expressed in terms of 
base address (of the object) and an offset (in bytes) to the member.
The \field{index} field of the abstract reference is an index into the member access partition.
Each entry of that partition has the following layout:
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{offset}{ExprIndex} \\
		\DeclareMember{enclosing}{TypeIndex} \\
		\DeclareMember{name}{TextOffset} \\
	}
	\caption{Structure of a member access expression}
	\label{fig:ifc:ExprSort:MemberAccess}
\end{figure}
%
The \field{locus} field designates the source location of this expression.
The \field{type} field denotes the type of the member access expression.
The \field{offset} is an expression designating the byte offset of the non-static data member
from the starting address of its enclosing object.
The member being accessed 
is indirectly described by its \field{enclosing} class type, and its \field{name}.

\partition{expr.member-access}

\note{This representation is subject to change in future releases.}

\subsection{\valueTag{ExprSort::InheritancePath}}
\label{sec:ifc:ExprSort:InheritancePath}

An \type{ExprIndex} value with tag \valueTag{ExprSort::InheritancePath} designates an expression ``path'' to a base-class subobject.
The \field{index} field of that abstract reference is an index into the inheritance path partition.
Each entry of that partition is a structure with the following layout
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{path}{ExprIndex} \\
	}
	\caption{Structure of an inheritance path expression}
	\label{fig:ifc-inheritance-path-expression-structure}
\end{figure}
%
The \field{locus} field designates the source location of this expression.
The \field{type} field denotes the type of the expression.
the \field{path} is a sequence of expressions designating each base-class component of the path.

\partition{expr.inheritance-path}

\subsection{\valueTag{ExprSort::InitializerList}}
\label{sec:ifc:ExprSort:InitializerList}

An \type{ExprIndex} value with tag \valueTag{ExprSort::InitializerList} designates a brace-enclosed comma-separated 
sequence of expressions.
The \field{index} field is an index into the partition of initializer list expressions.
Each entry in that partition is a structure with the following layout
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{elements}{ExprIndex} \\
	}
	\caption{Structure of an initializer-list expression}
	\label{fig:ifc-initializer-list-structure}
\end{figure}
%
The \field{elements} field denotes the sequence of expressions enclosed in the brace delimiters.

\partition{expr.initializer-list}



\subsection{\valueTag{ExprSort::Cast}}
\label{sec:ifc:ExprSort:Cast}

An \type{ExprIndex} value with tag \valueTag{ExprSort::Cast} designates a conversion operation.
The conversion may be explicit (in the input source code) and implicit (as required by semantics analysis).
The \field{index} field of this abstract reference  is a position into the partition of cast expressions.
Each entry in that partition is a structure with the following layout
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{source}{ExprIndex} \\
		\DeclareMember{target}{Index} \\
		\DeclareMember{operator}{DyadicOperator} \\
	}
	\caption{Structure of a cast expression}
	\label{fig:ifc:ExprSort:Cast}
\end{figure}
%
The \field{source} field denotes the operand expression, whereas the \field{target} field denotes
the type to convert that expression to.  The \field{operator} designates the sort of conversion operation
to perform.

\partition{expr.cast}


\subsection{\valueTag{ExprSort::Condition}}
\label{sec:ifc:ExprSort:Condition}

An \type{ExprIndex} value with tag \valueTag{ExprSort::Condition} designates a syntactic 
representation of an expression used as guarding predicate of an \code{if}-statement in a templated code.
The \field{index} field of this abstract reference is a position designating an entry of the
partition of syntactic condition expressions.  Each such an entry is a structure with the following layout
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{expr}{ExprIndex} \\
	}
	\caption{Structure of a condition expression}
	\label{fig:ifc:ExprSort:Condition}
\end{figure}
%
The \field{expr} field denotes the expression wrapped in this condition structure.

\partition{expr.condition}

\note{This structure is scheduled for removal in future releases.}


\subsection{\valueTag{ExprSort::ExpressionList}}
\label{sec:ifc:ExprSort:ExpressionList}

An \type{ExprIndex} value with tag \valueTag{ExprSort::ExpressionList} designates a syntactic representation
of a comma-separated sequence of expressions enclosed in a pair of matching delimiters, in a templated code.
The \field{index} field of this abstract reference is a position designating an entry of the partition of
syntactic expression-list expressions.  Each such entry is a structure with the following layout
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{left}{SourceLocation} \\
		\DeclareMember{right}{SourceLocation} \\
		\DeclareMember{contents}{ExprIndex} \\
		\DeclareMember{delimiter}{DelimiterSort} \\
	}
	\caption{Structure of an expression list}
	\label{fig:ifc:ExprSort:ExpressionList}
\end{figure}
%
The \field{left} field represents the source location of the opening delimiter, whereas the \field{right}
field represents the source location of the closing delimiter.
The \field{delimiter} field is of type
\begin{typedef}{DelimiterSort}{}
	enum class DelimiterSort : uint8_t {
		Unknown = 0,
		Brace = 1,
		Parenthesis = 2,
	};
\end{typedef}
and denotes the sort of delimiter:
\begin{itemize}
	\item \valueTag{DelimiterSort::Brace} for matching brace delimiters
	\item \valueTag{DelimiterSort::Parenthesis} for matching parenthesis delimiters
\end{itemize}

\partition{expr.expression-list}

\note{This structure is scheduled for removal in future releases.}


\subsection{\valueTag{ExprSort::SizeofType}}
\label{sec:ifc:ExprSort:SizeofType}

An \type{ExprIndex} value with tag \valueTag{ExprSort::SizeofType} designates a syntactic representation
of a \code{sizeof}-expression where the operand is a type.
The \field{index} field of this abstract reference is a position designating an entry of the partition
of syntactic \code{sizeof}-expressions.  Each such entry is a structure with the following layout
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{operand}{TypeIndex} \\
	}
	\caption{Structure of \code{sizeof} expression}
	\label{fig:ifc:ExprSort:SizeofType}
\end{figure}
%
The \field{operand} field designates the type operand to the \code{sizeof} operator in that expression.
The \field{type} field designates the type of the entire \code{sizeof}-expression.

\partition{expr.sizeof-type}

\note{This structure is subject to removal in future releases.}


\subsection{\valueTag{ExprSort::Alignof}}
\label{sec:ifc:ExprSort:Alignof}

An \type{ExprIndex} value with tag \valueTag{ExprSort::Alignof} designates a syntactic representation
of a \code{alignof}-expression.
The \field{index} field of this abstract reference is a position designating an entry of the partition
of syntactic \code{alignof}-expressions.  Each such entry is a structure with the following layout
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{operand}{TypeIndex} \\
	}
	\caption{Structure of \code{alignof} expression}
	\label{fig:ifc:ExprSort:Alignof}
\end{figure}

The \field{operand} field designates the operand to the \code{alignof} operator in that expression.
The \field{type} field designates the type of the entire \code{alignof}-expression.

\partition{expr.alignof}

\note{This representation is subject to change.}


\subsection{\valueTag{ExprSort::Label}}
\label{sec:ifc:ExprSort:Label}

An \type{ExprIndex} value with tag \valueTag{ExprSort::Label} designates a program point (as in a labeled statement).
The \field{index} field of this abstract reference is a position designating an entry of the partition
of program points.  Each such entry is a structure with the following layout
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{designator}{ExprIndex} \\
	}
	\caption{Structure of label expression}
	\label{fig:ifc:ExprSort:Label}
\end{figure}
%
The fields have the following meanings:
\begin{itemize}
	\item \field{locus} designates the source location of this label expression
	\item \field{type} designates the type of the program point expression
	\item \field{designator} designates the ``value'' (which could just be an identifier) of the program point
\end{itemize}

\note{This representation is subject to change}

\partition{expr.label}


\subsection{\valueTag{ExprSort::Unused0}}
\label{sec:ifc:ExprSort:Unused0}

No structure is associated with this sort value.

\subsection{\valueTag{ExprSort::Typeid}}
\label{sec:ifc:ExprSort:Typeid}

\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{operand}{TypeIndex} \\
	}
	\caption{Structure of a \code{typeid} expression}
	\label{fig:ifc-typeid-structure}
\end{figure}

The field \field{operand} designates the type operand to the \code{typeid}-expression.
The field \field{type} designates the type of the entire expression.

\partition{expr.typeid}


\subsection{\valueTag{ExprSort::DestructorCall}}
\label{sec:ifc:ExprSort:DestructorCall}

An \type{ExprIndex} value with tag \valueTag{ExprSort::DestructorCall} represents an abstract reference to 
a (pseudo-)destructor call.  The \field{index} field denotes a position of the corresponding entry in the destructor call partition.
Each entry of that partition is a structure with the following layout
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{object}{ExprIndex} \\
		\DeclareMember{decltype\_specifier}{SyntaxIndex} \\
		\DeclareMember{cleanup}{DestructorSort} \\
	}
	\caption{Structure of a destructor call}
	\label{fig:ifc-destructor-call-structure}
\end{figure}
%
with these meanings of the fields:
\begin{itemize}
	\item \field{locus} denotes the source location of this expression
	\item \field{type} denotes the type of this expression
	\item \field{object}, if non-null, denotes the object for which the destructor is called
	\item \field{decltype\_specifier}, if non-null, denotes the type providing the destructor function
	\item \field{cleanup} denotes the sort of destructor, the interpretation of which is determined by this table 
	\begin{itemize}
		\item $0$: the sort of destructor is unknown.  This should never occur in a valid IFC file.
		\item $1$: a standard C++ destructor.
		\item $2$: a CLI/.NET finalizer.
	\end{itemize}
\end{itemize}
and \newtype{DestructorSort}{8}

\partition{expr.destructor-call}

\note{This structure is subject to removal in future releases.}


\subsection{\valueTag{ExprSort::SyntaxTree}}
\label{sec:ifc:ExprSort:SyntaxTree}

\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{syntax}{SyntaxIndex} \\
	}
	\caption{Structure of a syntactic expression}
	\label{fig:ifc-syntax-expr-structure}
\end{figure}

\partition{expr.syntax-tree}


\subsection{\valueTag{ExprSort::FunctionString}}
\label{sec:ifc:ExprSort:FunctionString}

\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{macro}{TextOffset} \\
	}
	\caption{Structure of a function string expression}
	\label{fig:ifc-function-string-structure}
\end{figure}

\partition{expr.function-string}


\subsection{\valueTag{ExprSort::CompoundString}}
\label{sec:ifc:ExprSort:CompoundString}

\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{prefix}{TextOffset} \\
		\DeclareMember{string}{ExprIndex} \\
	}
	\caption{Structure of a compound string expression}
	\label{fig:ifc-compound-string-structure}
\end{figure}

\partition{expr.compound-string}


\subsection{\valueTag{ExprSort::StringSequence}}
\label{sec:ifc:ExprSort:StringSequence}

\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{strings}{ExprIndex} \\
	}
	\caption{Structure of a string sequence expression}
	\label{fig:ifc-string-sequence-structure}
\end{figure}

\partition{expr.string-sequence}


\subsection{\valueTag{ExprSort::Initializer}}
\label{sec:ifc:ExprSort:Initializer}

\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{expr}{ExprIndex} \\
		\DeclareMember{sort}{InitializerSort} \\
	}
	\caption{Structure of an initializer expression}
	\label{fig:ifc-initializer-structure}
\end{figure}
with \newtype{InitializerSort}{8}

The values of type \type{InitializerSort} are
\begin{SortEnum}{InitializerSort}
	\enumerator{Unknown}
	\enumerator{Direct}
	\enumerator{Copy}
\end{SortEnum}

\ifcdoc{Unknown}{InitializerSort}
No initializer expression of this sort shall be produced.  This value serves purely as a sentinel purpose.

\ifcdoc{Direct}{InitializerSort}
An initializer of this sort represents elaboration of a direct-initialization at the C++ input source level.

\ifcdoc{Copy}{InitializerSort}
An initializer of this sort represents an elaboration of a copy-initialization at the C++ input source level.

\partition{expr.initializer}


\subsection{\valueTag{ExprSort::Requires}}
\label{sec:ifc:ExprSort:Requires}

\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{parameters}{SyntaxIndex} \\
		\DeclareMember{body}{SyntaxtIndex} \\
	}
	\caption{Structure of a \code{requires} clause}
	\label{fig:requires-clause-structure}
\end{figure}

\partition{expr.requires}


\subsection{\valueTag{ExprSort::UnaryFold}}
\label{sec:ifc:ExprSort:UnaryFold}

\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{expr}{ExprIndex} \\
		\DeclareMember{operation}{DyadicOperator} \\
		\DeclareMember{associativity}{Associativity} \\
	}
	\caption{Structure of a unary fold expression}
	\label{fig:ifc-unary-fold-structure}
\end{figure}

with \newtype{Associativity}{8}

\partition{expr.unary-fold}


\subsection{\valueTag{ExprSort::BinaryFoid}}
\label{sec:ifc:ExprSort:BinaryFold}

\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{left}{ExprIndex} \\
		\DeclareMember{right}{ExprIndex} \\
		\DeclareMember{operation}{DyadicOperator} \\
		\DeclareMember{associativity}{Associativity} \\
	}
	\caption{Structure of a binary fold expression}
	\label{fig:ifc-binary-fold-structure}
\end{figure}

\partition{expr.binary-fold}


\subsection{\valueTag{ExprSort::HierarchyConversion}}
\label{sec:ifc:ExprSort:HierarchyConversion}

An \type{ExprIndex} value with tag \valueTag{ExprSort::HierarchyConversion} represents an expression that performs a class hierarchy conversion, i.e. class hierarchy navigation.
The \field{index} field is an index into the hierarchy conversion partition.  Each entry in that partition is a structure with the following fields
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{source}{ExprIndex} \\
		\DeclareMember{target}{TypeIndex} \\
		\DeclareMember{inheritance}{ExprIndex} \\
		\DeclareMember{override}{ExprIndex} \\
		\DeclareMember{operator}{DyadicOperator} \\
	}
	\caption{Structure of a hierarchy conversion expression}
	\label{fig:ifc-hierarchy-conversion-expression-structure}
\end{figure}
%

The \field{type} field designates the type of the overall expression.
The field \field{source} designates the operand expression.
The field \field{locus} designates the location of the expression.

\partition{expr.hierarchy-conversion}


\subsection{\valueTag{ExprSort::ProductTypeValue}}
\label{sec:ifc:ExprSort:ProductTypeValue}

An \type{ExprIndex} value with tag \valueTag{ExprSort::ProductTypeValue} designates an object of class type, usually produced as part of a compile-time evaluation.
The \field{index} field of that abstract reference is an index into the product type value partition.  Each entry in that partition is a structure with the following layout
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{structure}{TypeIndex} \\
		\DeclareMember{members}{ExprIndex} \\
		\DeclareMember{base\_subobjects}{ExprIndex} \\
	}
	\caption{Structure of a product value expression}
	\label{fig:ifc-product-value-structure}
\end{figure}
%
The meaning of the fields is as follows
\begin{itemize}
	\item \field{locus} denotes the source location of this expression.
	\item \field{type} denotes the type of this expression.
	\item \field{structure} denotes the class type of the object designated by this expression.
	\item \field{members} denotes the sequence of direct non-base class subobjects of the object.
	\item \field{base\_subobjects} denotes the sequence of base class subobjects of the object.
\end{itemize}

\partition{expr.product-type-value}

\note{This structure is subject to change in future releases}

\subsection{\valueTag{ExprSort::SumTypeValue}}
\label{sec:ifc:ExprSort:SumTypeValue}

An \type{ExprIndex} value with tag \valueTag{ExprSort::SumTypeValue} designates an object of a union type, usually produced as part of a compile-time evaluation.
The \field{index} field of that abstract reference is an index into the sum type value partition.  Each entry in that partition is a structure with the following layout
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{variant}{TypeIndex} \\
		\DeclareMember{discriminant}{ActiveMember} \\
		\DeclareMember{value}{ExprIndex} \\
	}
	\caption{Structure of a sum type value expression}
	\label{fig:ifc:ExprSort:SumTypeValue}
\end{figure}
%
with \newtype{ActiveMember}{32}.  The active member numbers the non-static data member in the union, starting from $0$.

The meaning of the fields is as follows
\begin{itemize}
	\item \field{locus} denotes the source location of this expression.
	\item \field{type} denotes the type of this expression.
	\item \field{variant} denotes the union class type of the object designated by this expression.
	\item \field{disciminant} denotes the index of the active member of the union object
	\item \field{value} denotes the value of the active member.
\end{itemize}

\partition{expr.sum-type-value}

\note{This structure is subject to change in future releases}


\subsection{\valueTag{ExprSort::SubobjectValue}}
\label{sec:ifc:ExprSort:SubobjectValue}

\partition{expr.class-subobject-value}

\note{This structure is scheduled for removal in future releases}


\subsection{\valueTag{ExprSort::ArrayValue}}
\label{sec:ifc:ExprSort:ArrayValue}

An \type{ExprIndex} value with tag \valueTag{ExprSort::ArrayValue} designates an object of an array type, usually produced as part of a compile-time evaluation.
The \field{index} field of that abstract reference is an index into the array value partition.  Each entry in that partition is a structure with the following layout
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{elements}{ExprIndex} \\
		\DeclareMember{element\_type}{TypeIndex} \\
	}
	\caption{Structure of an array value expression}
	\label{fig:ifc:ExprSort:ArrayValue}
\end{figure}
%
The meaning of the fields is as follows
\begin{itemize}
	\item \field{locus} denotes the source location of this expression.
	\item \field{type} denotes the type of this expression.
	\item \field{elements} denotes the sequence of subobjects of the array.
	\item \field{element\_type} denotes the (common) type of the array element.
\end{itemize}

\partition{expr.array-value}

\subsection{\valueTag{ExprSort::DynamicDispatch}}
\label{sec:ifc:ExprSort:DynamicDispatch}

\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{pivot}{ExprIndex} \\
	}
	\caption{Structure of a dynamic dispatch expression}
	\label{fig:ifc-dynamic-dispatch-structure}
\end{figure}

\partition{expr.dynamic-dispatch}


\subsection{\valueTag{ExprSort::VirtualFunctionConversion}}
\label{sec:ifc:ExprSort:VirtualFunctionConversion}

\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{function}{DeclIndex} \\
	}
	\caption{Structure of a virtual function conversion}
	\label{fig:ifc-virtual-function-conversion-structure}
\end{figure}

\partition{expr.virtual-function-conversion}


\subsection{\valueTag{ExprSort::Placeholder}}
\label{sec:ifc:ExprSort:Placeholder}

\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
	}
	\caption{Structure of a placeholder expression}
	\label{fig:ifc-placeholder-expr-structure}
\end{figure}

\partition{expr.placeholder}

\subsection{\valueTag{ExprSort::Expansion}}
\label{sec:ifc:ExprSort:Expansion}

\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{operand}{ExprIndex} \\
	}
	\caption{Structure of an expansion expression}
	\label{fig:ifc-expansion-expr-structure}
\end{figure}

\partition{expr.expansion}


\subsection{\valueTag{ExprSort::Generic}}
\label{sec:ifc:ExprSort:Generic}

\begin{figure}[H]
	\centering
	TBD
	\caption{Structure of a generic expression selection}
	\label{fig:ifc-generic-expr-structure}
\end{figure}

\partition{expr.generic}


\subsection{\valueTag{ExprSort::Tuple}}
\label{sec:ifc:ExprSort:Tuple}

A \type{ExprIndex} value with tag \valueTag{ExprSort::Tuple} represents a reference
to sequence or more abstract indices to expressions.  This is useful for representing expression lists,
including template argument lists.
The \field{index} field is index into the tuple expression partition.
Each entry in that partition has three components: a \field{start} field, a \field{cardinality} field, and a \field{locus} field.
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{start}{Index} \\
		\DeclareMember{cardinality}{Cardinality} \\
	}
	\caption{Structure of a tuple expression}
	\label{fig:ifc-tuple-expression-structure}
\end{figure}
%
The \field{start} field is an index into the expression heap partition. It points to the first expression abstract reference in the tuple.
The \field{cardinality} field denotes the number of expression abstract references in the tuple.
The \field{locus} field denotes the source location of the expression.

\partition{expr.tuple}


\subsection{\valueTag{ExprSort::Nullptr}}
\label{sec:ifc:ExprSort:Nullptr}

\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
	}
	\caption{Structure of a \code{nullptr} expression}
	\label{fig:ifc-nullptr-expr-structure}
\end{figure}

\partition{expr.nullptr}

\subsection{\valueTag{ExprSort::This}}
\label{sec:ifc:ExprSort:This}

\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
	}
	\caption{Structure of a \code{this} expression}
	\label{fig:ifc-this-expr-structure}
\end{figure}

\partition{expr.this}


\subsection{\valueTag{ExprSort::TemplateReference}}
\label{sec:ifc:ExprSort:TemplateReference}

A reference to a member of a template
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{member}{DeclIndex} \\
		\DeclareMember{member\_name}{NameIndex} \\
		\DeclareMember{scope}{TypeIndex} \\
		\DeclareMember{arguments}{ExprIndex} \\
	}
	\caption{Structure of a template member expression}
	\label{fig:ifc-member-template-expression-structure}
\end{figure}
%
with the following meanings for the fields
\begin{itemize}
	\item \field{locus} designates the source location of the reference to the template member
	\item \field{type} designates the type of this expression
	\item \field{member} designates the declaration of the template member
	\item \field{member\_name} designates the name of the referenced template member
	\item \field{scope} field designates the enclosing scope of the member
	\item \field{arguments} designates the set of template arguments to this member
\end{itemize}


\partition{expr.template-reference}

\note{This structure is subject to removal in future releases.}

\subsection{\valueTag{ExprSort::Statement}}
\label{sec:ifc:ExprSort:Statement}

A \type{ExprIndex} value with tag \valueTag{ExprSort::Statement} represents an abstract reference to a statement used
 in a context where an expression would normally occur.  Such a context could be in support of code transformation that
expands a function call to its body where arguments are substituted for parameters, or in support of some extensions
such as ``statement expressions''.  Yet, another context would be to satisfy IFC-internal typing requirements 
where a structure is notionally a statement, but needs to appear as argument to an operator expecting an expression
structure.  In such cases, this structure effectively acts as an embedding of a statement structure in the 
expression sort category.  The \field{index} is an index into the statement-as-expression partition.
Each entry in that partition is a structure with the following layout
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{stmt}{StmtIndex} \\
	}
\end{figure}
%
and meanings for the fields
\begin{itemize}
	\item \field{stmt} designates the statement being embedded in the expression sort category.
\end{itemize}


\subsection{\valueTag{ExprSort::TypeTraitIntrinsic}}
\label{sec:ifc:ExprSort:TypeTraitIntrinsic}

A use of a type trait intrinsic

%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{arguments}{TypeIndex} \\
		\DeclareMember{intrinsic}{Operator} \\
	}
	\caption{Structure of an intrinsic type-trait expression}
	\label{fig:ifc-type-trait-expression-structure}
\end{figure}

\partition{expr.type-trait}


\subsection{\valueTag{ExprSort::DesignatedInitializer}}
\label{sec:ifc:ExprSort:DesignatedInitializer}

\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{member}{TextOffset} \\
		\DeclareMember{initializer}{ExprIndex} \\
	}
	\caption{Structure of a designated initializer}
	\label{fig:ifc-designated-initializer-structure}
\end{figure}

\partition{expr.designated-init}

\subsection{\valueTag{ExprSort::PackedTemplateArguments}}
\label{sec:ifc:ExprSort:PackedTemplateArguments}

A \type{ExprIndex} value with tag \valueTag{ExprIndex::PackedTemplateArguments} represents an
abstract reference to a template argument list for a template parameter pack.  The 
\field{index} field of that abstract reference is an index into the packed template-argument
list partition.  Each entry in that partition is a structure with the following layout:
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{arguments}{ExprIndex} \\
	}
\end{figure}
%
with the these meanings of the fields:
\begin{itemize}
	\item \field{locus} designates the source location of the expression
	\item \field{type} designates the type of the expression -- currently null
	\item \field{arguments} designate the actual argument, or sequence of template-arguments.
\end{itemize}

\partition{expr.packed-template-arguments}

\note{This representation is subject to change.}



%% \section{\valueTag{ExprSort::Brace}}
%% A \type{ExprIndex} with tag \valueTag{ExprSort::Brace} represents a reference to a brace-enclosed expression.
%% The \field{value} field is an index into the brace expression partition.
%% Each entry in that partition is a structure with three components: a \field{type} field, a \field{enclosed} field, and a \field{locus} field.
%% %
%% \begin{figure}[h]
%%	\centering
%%	\begin{tikzpicture}
%%	\matrix[matrix of nodes,
%%			row sep=-\pgflinewidth,
%%			nodes={rectangle,draw,anchor=west,text width=12em}]
%%	{
%%		\DeclareMember{type}{TypeIndex} \\
%%		\DeclareMember{enclosed}{Expr} \\
%%		\DeclareMember{locus}{SourceLocation} \\
%%	};
%%	\end{tikzpicture}
%%	\caption{Structure of a brace expression}
%%	\label{fig:ifc-brace-expression-structure}
%%\end{figure}
%%%
%% The \field{type} field denotes the type of the expression.
%% The \field{enclosed} field denoted the expression surrounded by the braces.
%% The \field{locus} field denotes the source location.


\subsection{\valueTag{ExprSort::Tokens}}
\label{sec:ifc:ExprSort:Tokens}

A \type{ExprIndex} value with tag \valueTag{ExprSort::Tokens} represents an arbitrary token sequence (yet to be parsed) denoting an expression. 
The \field{index} field is an index into to the token sequence expression partition.
Each entry of that partition is a structure with the following components: a \field{tokens} field, and a \field{locus} field.
%
\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{locus}{SourceLocation} \\
		\DeclareMember{type}{TypeIndex} \\
		\DeclareMember{words}{SentenceIndex} \\
	}
	\caption{Structure of a token sequence expression}
	\label{fig:ifc-token-sequence-expression-structure}
\end{figure}
%
The \field{words} field is an index into the sentence partition (\secref{sec:ifc-token-streams}).
The \field{locus} field denotes the source location.

\partition{expr.tokens}

\paragraph{Note:} This kind of representation of expression is discouraged and will be removed in future version of this document.



\subsection{\valueTag{ExprSort::AssignInitializer}}
\label{sec:ifc:ExprSort:AssignInitializer}

\partition{expr.assign-initializer}

\begin{figure}[H]
	\centering
	\structure{
		\DeclareMember{equal}{SourceLocation} \\
		\DeclareMember{initializer}{ExprIndex} \\
	}
\end{figure}


\section{Operators}
\label{sec:ifc-operators}

Elaboration of C++ expressions involves semantic operators which are classified
by sort. Semantic operators are $16$-bit precision values with the following
layout:
%
\begin{figure}[H]
	\centering
	  \begin{BasicAbstractReferenceLayout}{16}
		  \bitfield{4}{\field{sort}}
				\bitfield{12}{\field{index}}
		  \bitFormatTextAt{3}{3}
		   \bitSeparate{4}
		  \bitFormatTextAt{4}{4}
	  \end{BasicAbstractReferenceLayout} 
	  \caption{\type{Operator}: Structure of semantic operator}
	  \label{fig:ifc-semantic-operator}
\end{figure}
%

The field \field{sort}, of type \type{OperatorSort}, designates the semantic category
of the operator.  The field \field{index} is a $12$-bit value the 
interpretation of which is \field{sort}-dependent as indicated in the 
subsections below.

The type \type{OperatorSort} is a set of $4$-bit values enumerated as follows.
\begin{Enumeration}{OperatorSort}
	\enumerator{Niladic}
	\enumerator{Monadic}
	\enumerator{Dyadic}
	\enumerator{Triadic}
	
	\setcounter{enumi}{13}
	\enumerator{Storage}
	\enumerator{Variadic}
\end{Enumeration}

\subsection{Niladic operators}
\label{sec:ifc:OperatorSort:Niladic}

A sort value \valueTag{OperatorSort::Niladic} indicates a niladic operator -- 
an operator accepting no argument.  The
value of the \field{index} is to be interpreted as a value of type 
\type{NiladicOperator}, which is a set of $12$-bit values enumerated as follows.
%
\begin{Enumeration}{NiladicOperator}
	\enumerator{Unknown}
	\enumerator{Phantom}
	\enumerator{Constant}
	\enumerator{Nil}

	\setcounter{enumi}{1023}
	\enumerator{Msvc}
	\enumerator{MsvcConstantObject}
	\enumerator{MsvcLambda}
\end{Enumeration}

\ifcSortSection{Unknown}{NiladicOperator}
An invalid niladic operator, sometimes stands for an undefined value.

\ifcSortSection{Phantom}{NiladicOperator}
A missing expression in the input source level, e.g. as the array bound the type \code{int[]}.

\ifcSortSection{Constant}{NiladicOperator}
A scalar constant, or string literal, or a class type object constant expression.

\ifcSortSection{Nil}{NiladicOperator}
Representation of the source level semantic equivalent of \code{void()}.

\ifcSortSection{Msvc}{NiladicOperator} 
This is a marker, not an actual operator. Niladic operators with 
value greater that this are MSVC extensions.

\ifcSortSection{MsvcConstantObject}{NiladicOperator}
An MSVC extension for representing class type object constants.
Semantically, this is the same as \sortref{Constant}{NiladicOperator}.

\note{This representation is scheduled for removal in future MSVC releases.}

\ifcSortSection{MsvcLambda}{NiladicOperator}
An MSVC extension to represent a lambda constant.
Semantically, this is the same as \sortref{Constant}{NiladicOperator}.

\note{This representation is scheduled for removal in future MSVC releases.}


\subsection{Monadic operators}
\label{sec:ifc:OperatorSort:Monadic}

A sort value \valueTag{OperatorSort::Monadic} indicates a monadic operator -- 
an operator accepting one argument.  The
value of the \field{index} is to be interpreted as a value of type 
\type{MonadicOperator}, which is a set of $12$-bit values enumerated as follows.
%
\begin{Enumeration}{MonadicOperator}
	\enumerator{Unknown}
	\enumerator{Plus}
	\enumerator{Negate}
	\enumerator{Deref}
	\enumerator{Address}
	\enumerator{Complement}
	\enumerator{Not}
	\enumerator{PreIncrement}
	\enumerator{PreDecrement}
	\enumerator{PostIncrement}
	\enumerator{PostDecrement}
	\enumerator{Truncate}
	\enumerator{Ceil}
	\enumerator{Floor}
	\enumerator{Paren}
	\enumerator{Brace}
	\enumerator{Alignas}
	\enumerator{Alignof}
	\enumerator{Sizeof}
	\enumerator{Cardinality}
	\enumerator{Typeid}
	\enumerator{Noexcept}
	\enumerator{Requires}
	\enumerator{CoReturn}
	\enumerator{Await}
	\enumerator{Yield}
	\enumerator{Throw}
	\enumerator{New}
	\enumerator{Delete}
	\enumerator{DeleteArray}
	\enumerator{Expand}
	\enumerator{Read}
	\enumerator{Materialize}
	\enumerator{PseudoDtorCall}
	\enumerator{LookupGlobally}

	\setcounter{enumi}{1023}
	\enumerator{Msvc}
	\enumerator{MsvcAssume}
	\enumerator{MsvcAlignof}
	\enumerator{MsvcUuidof}
	\enumerator{MsvcIsClass}
	\enumerator{MsvcIsUnion}
	\enumerator{MsvcIsEnum}
	\enumerator{MsvcIsPolymorphic}
	\enumerator{MsvcIsEmpty}
	\enumerator{MsvcIsTriviallyCopyConstructible}
	\enumerator{MsvcIsTriviallyCopyAssignable}
	\enumerator{MsvcIsTriviallyDestructible}
	\enumerator{MsvcHasVirtualDestructor}
	\enumerator{MsvcIsNothrowCopyConstructible}
	\enumerator{MsvcIsNothrowCopyAssignable}
	\enumerator{MsvcIsPod}
	\enumerator{MsvcIsAbstract}
	\enumerator{MsvcIsTrivial}
	\enumerator{MsvcIsTriviallyCopyable}
	\enumerator{MsvcIsStandardLayout}
	\enumerator{MsvcIsLiteralType}
	\enumerator{MsvcIsTriviallyMoveConstructible}
	\enumerator{MsvcHasTrivialMoveAssign}
	\enumerator{MsvcIsTriviallyMoveAssignable}
	\enumerator{MsvcIsNothrowMoveAssignable}
	\enumerator{MsvcUnderlyingType}
	\enumerator{MsvcIsDestructible}
	\enumerator{MsvcIsNothrowDestructible}
	\enumerator{MsvcHasUniqueObjectRepresentations}
	\enumerator{MsvcIsAggregate}
	\enumerator{MsvcBuiltinAddressOf}
	\enumerator{MsvcIsRefClass}
	\enumerator{MsvcIsValueClass}
	\enumerator{MsvcIsSimpleValueClass}
	\enumerator{MsvcIsInterfaceClass}
	\enumerator{MsvcIsDelegate}
	\enumerator{MsvcIsFinal}
	\enumerator{MsvcIsSealed}
	\enumerator{MsvcHasFinalizer}
	\enumerator{MsvcHasCopy}
	\enumerator{MsvcHasAssign}
	\enumerator{MsvcHasUserDestructor}

	\setcounter{enumi}{4063}
	\enumerator{MsvcConfusion}
	\enumerator{MsvcConfusedExpand}
	\enumerator{MsvcConfusedDependentSizeof}
	\enumerator{MsvcConfusedPopState}
	\enumerator{MsvcConfusedDtorAction}
	\enumerator{MsvcConfusedVtorDisplacement}
	\enumerator{MsvcConfusedDependentExpression}
	\enumerator{MsvcConfusedSubstitution}
	\enumerator{MsvcConfusedAggregateReturn}
\end{Enumeration}

\ifcSortSection{Unknown}{MonadicOperator} 
An invalid monadic operator.  This value should never be generated.

\ifcSortSection{Plus}{MonadicOperator}
Source-level prefix ``\code{+}'' operator.

\ifcSortSection{Negate}{MonadicOperator} 
Source-level prefix ``\code{-}'' operator. 

\ifcSortSection{Deref}{MonadicOperator}
Source-level (pointer) dereference ``\code{*}'' operator.

\ifcSortSection{Address}{MonadicOperator}
Source-level address-of ``\code{\&}'' operator.

\ifcSortSection{Complement}{MonadicOperator}
Source-level bit complement ``\code{\~}'' operator.

\ifcSortSection{Not}{MonadicOperator}
Source-level logical prefix ``\code{\!}'' (i.e. ``\code{not}'') operator.

\ifcSortSection{PreIncrement}{MonadicOperator} 
Source-level prefix ``\code{++}'' operator.

\ifcSortSection{PreDecrement}{MonadicOperator}
Source-level prefix ``\code{--}'' operator.

\ifcSortSection{PostIncrement}{MonadicOperator} 
Source-level postfix ``\code{++}'' operator.

\ifcSortSection{PostDecrement}{MonadicOperator}
Source-level postfix ``\code{--}'' operator.

\ifcSortSection{Truncate}{MonadicOperator} C++ abstract machine operator.

\ifcSortSection{Ceil}{MonadicOperator} C++ abstract machine operator.

\ifcSortSection{Floor}{MonadicOperator} C++ abstract machine operator.

\ifcSortSection{Paren}{MonadicOperator} Source-level parenthesis-enclosing operator.

\ifcSortSection{Brace}{MonadicOperator} Source-level brace-enclosing operator.

\ifcSortSection{Alignas}{MonadicOperator} Source-level ``\code{alignas}'' operator.
\ifcSortSection{Alignof}{MonadicOperator} Source-level ``\code{alignof}'' operator.
\ifcSortSection{Sizeof}{MonadicOperator} Source-level ``\code{sizeof}'' operator.
\ifcSortSection{Cardinality}{MonadicOperator} Source-level ``\code{sizeof...}'' operator.
\ifcSortSection{Typeid}{MonadicOperator} Source-level ``\code{typeid}'' operator.
\ifcSortSection{Noexcept}{MonadicOperator} Source-level ``\code{noexpcet}'' operator.
\ifcSortSection{Requires}{MonadicOperator} Source-level ``\code{requires}'' operator.
\ifcSortSection{CoReturn}{MonadicOperator} Source-level ``\code{co_return}'' operator.
\ifcSortSection{Await}{MonadicOperator} Source-level ``\code{co_await}'' operator.
\ifcSortSection{Yield}{MonadicOperator} Source-level ``\code{co_yield}'' operator.
\ifcSortSection{Throw}{MonadicOperator} Source-level ``\code{throw}'' operator.
\ifcSortSection{New}{MonadicOperator} Source-level ``\code{new}'' operator.
\ifcSortSection{Delete}{MonadicOperator} Source-level ``\code{delete}'' operator.
\ifcSortSection{DeleteArray}{MonadicOperator} Source-level ``\code{delete[]}'' operator.
\ifcSortSection{Expand}{MonadicOperator} Source-level pack-expansion operator.
\ifcSortSection{Read}{MonadicOperator} C++ abstract machine lvalue-to-rvalue conversion operator.
\ifcSortSection{Materialize}{MonadicOperator} C++ abstract machine class temporary materialization operator.
\ifcSortSection{PseudoDtorCall}{MonadicOperator} Pseudo-destructor call operator.
\ifcSortSection{LookupGlobally}{MonadicOperator} Any operator in the immediate operand expression, at source-level, is to be looked-up in the global scope.  For example, in \code{::new T(a, b)}, the corresponding storage allocation function \code{operator new} is to be looked up in the global scope.

\ifcSortSection{Msvc}{MonadicOperator} This is a marker, not an actual operator. Monadic operators with 
value greater that this are MSVC extensions.

\ifcSortSection{MsvcAssume}{MonadicOperator} 
Source-level ``\code{__assume}'' operator (\sortref{MsvcAssume}{SourceKeyword}).

\ifcSortSection{MsvcAlignof}{MonadicOperator}
 Source-level ``\code{__builtin_alignof}'' operator (\sortref{MsvcAlignof}{SourceKeyword}).

\ifcSortSection{MsvcUuidof}{MonadicOperator}
 Source-level ``\code{__uuidof}'' operator (\sortref{MsvcUuidof}{SourceKeyword}).

\ifcSortSection{MsvcIsClass}{MonadicOperator}
 Source-level ``\code{__is_class}'' operator (\sortref{MsvcIsClass}{SourceKeyword}).

\ifcSortSection{MsvcIsUnion}{MonadicOperator}
 Source-level ``\code{__is_union}'' operator (\sortref{MsvcIsUnion}{SourceKeyword}).

\ifcSortSection{MsvcIsEnum}{MonadicOperator}
 Source-level ``\code{__is_enum}'' operator (\sortref{MsvcIsEnum}{SourceKeyword}).

\ifcSortSection{MsvcIsPolymorphic}{MonadicOperator}
 Source-level ``\code{__is_polymorphic}'' operator (\sortref{MsvcIsPolymorphic}{SourceKeyword}).

\ifcSortSection{MsvcIsEmpty}{MonadicOperator}
 Source-level ``\code{__is_empty}'' operator (\sortref{MsvcIsEmpty}{SourceKeyword}).

\ifcSortSection{MsvcIsTriviallyCopyConstructible}{MonadicOperator}
 Source-level ``\code{__is_trivially_copy_constructible}'' operator (\sortref{MsvcIsTriviallyCopyConstructible}{SourceKeyword}).

\ifcSortSection{MsvcIsTriviallyCopyAssignable}{MonadicOperator}
Source-level ``\code{__is_trivially_copy_constructible}'' operator (\sortref{MsvcIsTriviallyCopyAssignable}{SourceKeyword}).

\ifcSortSection{MsvcIsTriviallyDestructible}{MonadicOperator}
Source-level ``\code{__is_trivially_destructible}'' operator (\sortref{MsvcIsTriviallyDestructible}{SourceKeyword}).

\ifcSortSection{MsvcHasVirtualDestructor}{MonadicOperator}
Source-level ``\code{__has_virtual_destructor}'' operator (\sortref{MsvcHasVirtualDestructor}{SourceKeyword}).

\ifcSortSection{MsvcIsNothrowCopyConstructible}{MonadicOperator}
Source-level ``\code{__is_nothrow_copy_constructible}'' operator (\sortref{MsvcIsNothrowCopyConstructible}{SourceKeyword}).

\ifcSortSection{MsvcIsNothrowCopyAssignable}{MonadicOperator}
Source-level ``\code{__is_nothrow_copy_assignable}'' operator (\sortref{MsvcIsNothrowCopyAssignable}{SourceKeyword}).

\ifcSortSection{MsvcIsPod}{MonadicOperator}
Source-level ``\code{__is_pod}'' operator (\sortref{MsvcIsPod}{SourceKeyword}).

\ifcSortSection{MsvcIsAbstract}{MonadicOperator}
Source-level ``\code{__is_abstract}'' operator (\sortref{MsvcIsAbstract}{SourceKeyword}).

\ifcSortSection{MsvcIsTrivial}{MonadicOperator}
Source-level ``\code{__is_trivial}'' operator (\sortref{MsvcIsTrivial}{SourceKeyword}).

\ifcSortSection{MsvcIsTriviallyCopyable}{MonadicOperator}
Source-level ``\code{__is_trivially_copyable}'' operator (\sortref{MsvcIsTriviallyCopyable}{SourceKeyword}).

\ifcSortSection{MsvcIsStandardLayout}{MonadicOperator}
Source-level ``\code{__is_standard_layout}'' operator (\sortref{MsvcIsStandardLayout}{SourceKeyword}).

\ifcSortSection{MsvcIsLiteralType}{MonadicOperator}
Source-level ``\code{__is_literal_type}'' operator (\sortref{MsvcIsLiteralType}{SourceKeyword}).

\ifcSortSection{MsvcIsTriviallyMoveConstructible}{MonadicOperator}
Source-level ``\code{__is_trivially_move_constructible}'' operator (\sortref{MsvcIsTriviallyMoveConstructible}{SourceKeyword}).

\ifcSortSection{MsvcHasTrivialMoveAssign}{MonadicOperator}
Source-level ``\code{__has_trivial_move_assign}'' operator (\sortref{MsvcHasTrivialMoveAssign}{SourceKeyword}).

\ifcSortSection{MsvcIsTriviallyMoveAssignable}{MonadicOperator}
Source-level ``\code{__is_trivially_move_assignable}'' operator (\sortref{MsvcIsTriviallyMoveAssignable}{SourceKeyword}).

\ifcSortSection{MsvcIsNothrowMoveAssignable}{MonadicOperator}
Source-level ``\code{__is_nothrow_move_assignable}'' operator (\sortref{MsvcIsNothrowMoveAssignable}{SourceKeyword}).

\ifcSortSection{MsvcUnderlyingType}{MonadicOperator}
Source-level ``\code{__underlying_type}'' operator (\sortref{MsvcUnderlyingType}{SourceKeyword}).

\ifcSortSection{MsvcIsDestructible}{MonadicOperator}
Source-level ``\code{__is_destructible}'' operator (\sortref{MsvcIsDestructible}{SourceKeyword}).

\ifcSortSection{MsvcIsNothrowDestructible}{MonadicOperator}
Source-level ``\code{__is_nothrow_destructible}'' operator (\sortref{MsvcIsNothrowDestructible}{SourceKeyword}).

\ifcSortSection{MsvcHasUniqueObjectRepresentations}{MonadicOperator}
Source-level ``\code{__has_unique_object_representations}'' operator (\sortref{MsvcHasUniqueObjectRepresentations}{SourceKeyword}).

\ifcSortSection{MsvcIsAggregate}{MonadicOperator}
Source-level ``\code{__is_aggregate}'' operator (\sortref{MsvcIsAggregate}{SourceKeyword}).

\ifcSortSection{MsvcBuiltinAddressOf}{MonadicOperator}
Source-level ``\code{__builtin_addressof}'' operator (\sortref{MsvcBuiltinAddressOf}{SourceKeyword}).

\ifcSortSection{MsvcIsRefClass}{MonadicOperator}
Source-level ``\code{__is_ref_class}'' operator (\sortref{MsvcIsRefClass}{SourceKeyword}).

\ifcSortSection{MsvcIsValueClass}{MonadicOperator}
Source-level ``\code{__is_value_class}'' operator (\sortref{MsvcIsValueClass}{SourceKeyword}).

\ifcSortSection{MsvcIsSimpleValueClass}{MonadicOperator}
Source-level ``\code{__is_simple_value_class}'' operator (\sortref{MsvcIsSimpleValueClass}{SourceKeyword}).

\ifcSortSection{MsvcIsInterfaceClass}{MonadicOperator}
Source-level ``\code{__is_interface_class}'' operator (\sortref{MsvcIsInterfaceClass}{SourceKeyword}).

\ifcSortSection{MsvcIsDelegate}{MonadicOperator}
Source-level ``\code{__is_delegate}'' operator (\sortref{MsvcIsDelegate}{SourceKeyword}).

\ifcSortSection{MsvcIsFinal}{MonadicOperator}
Source-level ``\code{__is_final}'' operator (\sortref{MsvcIsFinal}{SourceKeyword}).

\ifcSortSection{MsvcIsSealed}{MonadicOperator}
Source-level ``\code{__is_sealed}'' operator (\sortref{MsvcIsSealed}{SourceKeyword}).

\ifcSortSection{MsvcHasFinalizer}{MonadicOperator}
Source-level ``\code{__has_finalizer}'' operator (\sortref{MsvcHasFinalizer}{SourceKeyword}).

\ifcSortSection{MsvcHasCopy}{MonadicOperator}
Source-level ``\code{__has_copy}'' operator (\sortref{MsvcHasCopy}{SourceKeyword}).

\ifcSortSection{MsvcHasAssign}{MonadicOperator}
Source-level ``\code{__has_assign}'' operator (\sortref{MsvcHasAssign}{SourceKeyword}).

\ifcSortSection{MsvcHasUserDestructor}{MonadicOperator}
Source-level ``\code{__has_user_destructor}'' operator (\sortref{MsvcHasUserDestructor}{SourceKeyword}).


\ifcSortSection{MsvcConfusion}{MonadicOperator}
This is not a real operator, rather a sentinel value.  Monadic operator values greater than this
have alternate representations, and signify some infelicities in the MSVC parser.  They are
scheduled to be removed in future releases.

\ifcSortSection{MsvcConfusedExpand}{MonadicOperator}
Source-level pack expansion ``\code{...}'' operator.

\ifcSortSection{MsvcConfusedDependentSizeof}{MonadicOperator}
Source-level \code{sizeof} operator, used in an expression where the operand is dependent.

\ifcSortSection{MsvcConfusedDependentExpression}{MonadicOperator}
This operator indicates a weakness in the current MSVC parser whereby certain expressions are explicitly
marked dependent (with no indication of whether they are type-dependent or value-dependent).

\ifcSortSection{MsvcConfusedSubstitution}{MonadicOperator}
This operator indicates a substitution of an expression (the operand) for a template parameter declaration
(the implementation field of the monadic tree).

\ifcSortSection{MsvcConfusedAggregateReturn}{MonadicOperator}
This operator indicates a semantic action of a \code{return} statement where the expression-to-return
evaluates to an aggregate with at least one subobject having non-trivial destructor.

\subsection{Dyadic operators}
\label{sec:ifc:OperatorSort:Dyadic}

A sort value \valueTag{OperatorSort::Dyadic} indicates a dyadic operator -- 
an operator accepting two arguments.  The
value of the \field{index} is to be interpreted as a value of type 
\type{DyadicOperator}, which is a set of $12$-bit values enumerated as follows.
%
\begin{Enumeration}{DyadicOperator}
	\enumerator{Unknown}
	\enumerator{Plus}
	\enumerator{Minus}
	\enumerator{Mult}
	\enumerator{Slash}
	\enumerator{Modulo}
	\enumerator{Remainder}
	\enumerator{Bitand}
	\enumerator{Bitor}
	\enumerator{Bitxor}
	\enumerator{Lshift}
	\enumerator{Rshift}
	\enumerator{Equal}
	\enumerator{NotEqual}
	\enumerator{Less}
	\enumerator{LessEqual}
	\enumerator{Greater}
	\enumerator{GreaterEqual}
	\enumerator{Compare}
	\enumerator{LogicAnd}
	\enumerator{LogicOr}
	\enumerator{Assign}
	\enumerator{PlusAssign}
	\enumerator{MinusAssign}
	\enumerator{MultAssign}
	\enumerator{SlashAssign}
	\enumerator{ModuloAssign}
	\enumerator{BitandAssign}
	\enumerator{BitorAssign}
	\enumerator{BitxorAssign}
	\enumerator{LshiftAssign}
	\enumerator{RshiftAssign}
	\enumerator{Comma}
	\enumerator{Dot}
	\enumerator{Arrow}
	\enumerator{DotStar}
	\enumerator{ArrowStar}
	\enumerator{Curry}
	\enumerator{Apply}
	\enumerator{Index}
	\enumerator{DefaultAt}
	\enumerator{New}
	\enumerator{NewArray}
	\enumerator{Destruct}
	\enumerator{DestructAt}
	\enumerator{Cleanup}
	\enumerator{Qualification}
	\enumerator{Promote}
	\enumerator{Demote}
	\enumerator{Coerce}
	\enumerator{Rewrite}
	\enumerator{Bless}
	\enumerator{Cast}
	\enumerator{ExplicitConversion}
	\enumerator{ReinterpretCast}
	\enumerator{StaticCast}
	\enumerator{ConstCast}
	\enumerator{DynamicCast}
	\enumerator{Narrow}
	\enumerator{Widen}
	\enumerator{Pretend}
	\enumerator{Closure}
	\enumerator{ZeroInitialize}
	\enumerator{ClearStorage}
	\enumerator{Select}

	\setcounter{enumi}{1023}
	\enumerator{Msvc}
	\enumerator{MsvcTryCast}
	\enumerator{MsvcCurry}
	\enumerator{MsvcVirtualCurry}
	\enumerator{MsvcAlign}
	\enumerator{MsvcBitSpan}
	\enumerator{MsvcBitfieldAccess}
	\enumerator{MsvcObscureBitfieldAccess}
	\enumerator{MsvcInitialize}
	\enumerator{MsvcBuiltinOffsetOf}
	\enumerator{MsvcIsBaseOf}
	\enumerator{MsvcIsConvertibleTo}
	\enumerator{MsvcIsTriviallyAssignable}
	\enumerator{MsvcIsNothrowAssignable}
	\enumerator{MsvcIsAssignable}
	\enumerator{MsvcIsAssignableNocheck}
	\enumerator{MsvcBuiltinBitCast}
	\enumerator{MsvcBuiltinIsLayoutCompatible}
	\enumerator{MsvcBuiltinIsPointerInterconvertibleBaseOf}
	\enumerator{MsvcBuiltinIsPointerInterconvertibleWithClass}
	\enumerator{MsvcBuiltinIsCorrespondingMember}
	\enumerator{MsvcIntrinsic}
	\enumerator{MsvcSaturatedArithmetic}
	\enumerator{MsvcBuiltinAllocationAnnotation}
\end{Enumeration}

\ifcSortSection{Unknown}{DyadicOperator} 
An invalid dyadic operator.  This value should never be generated.

\ifcSortSection{Plus}{DyadicOperator}
Source level binary operator ``\code{+}''.

\ifcSortSection{Minus}{DyadicOperator}
Source level binary operator ``\code{-}''.

\ifcSortSection{Mult}{DyadicOperator}
Source level binary operator ``\code{*}''.

\ifcSortSection{Slash}{DyadicOperator}
Source level binary operator ``\code{/}''.

\ifcSortSection{Modulo}{DyadicOperator}
The Euclidean modulo operator at the abstract machine semantics level.
At source level, this corresponds to the binary operator ``\code{\%}''.
When both operands are integers, the result is always non-negative, between $0$ and the absolute value of the second operand.
See also \sortref{Remainder}{DyadicOperator}.

\ifcSortSection{Remainder}{DyadicOperator}
Source level binary operator ``\code{\%}''. 
When both operands are integers the result is truncated towards 0 as defined the corresponding ISO standards of C11 and up, and C++11 and up, 
See also \sortref{Modulo}{DyadicOperator}.

\ifcSortSection{Bitand}{DyadicOperator}
Source level binary operator ``\code{\&}''.

\ifcSortSection{Bitor}{DyadicOperator}
Source level binary operator ``\code{|}''.

\ifcSortSection{Bitxor}{DyadicOperator}
Source level binary operator ``\code{\^}''.

\ifcSortSection{Lshift}{DyadicOperator}
Source level binary operator ``\code{<<}''.

\ifcSortSection{Rshift}{DyadicOperator}
Source level binary operator ``\code{>>}''.

\ifcSortSection{Equal}{DyadicOperator}
Source level binary operator ``\code{==}''.

\ifcSortSection{NotEqual}{DyadicOperator}
Source level binary operator ``\code{!=}''.

\ifcSortSection{Less}{DyadicOperator}
Source level binary operator ``\code{<}''.

\ifcSortSection{LessEqual}{DyadicOperator}
Source level binary operator ``\code{<=}''.

\ifcSortSection{Greater}{DyadicOperator}
Source level binary operator ``\code{>}''.

\ifcSortSection{GreaterEqual}{DyadicOperator}
Source level binary operator ``\code{>=}''.

\ifcSortSection{Compare}{DyadicOperator}
Source level binary operator ``\code{<=>}''.

\ifcSortSection{LogicAnd}{DyadicOperator}
Source level binary operator ``\code{\&\&}''.


\ifcSortSection{LogicOr}{DyadicOperator}
Source level binary operator ``\code{||}''.

\ifcSortSection{Assign}{DyadicOperator}
Source level binary operator ``\code{=}''.

\ifcSortSection{PlusAssign}{DyadicOperator}
Source level binary operator ``\code{+=}''.

\ifcSortSection{MinusAssign}{DyadicOperator}
Source level binary operator ``\code{-=}''.

\ifcSortSection{MultAssign}{DyadicOperator}
Source level binary operator ``\code{*=}''.

\ifcSortSection{SlashAssign}{DyadicOperator}
Source level binary operator ``\code{/=}''.

\ifcSortSection{ModuloAssign}{DyadicOperator}
Source level binary operator ``\code{\%=}''.

\ifcSortSection{BitandAssign}{DyadicOperator}
Source level binary operator ``\code{\&=}''.

\ifcSortSection{BitorAssign}{DyadicOperator}
Source level binary operator ``\code{|=}''.

\ifcSortSection{BitxorAssign}{DyadicOperator}
Source level binary operator ``\code{\^=}''.

\ifcSortSection{LshiftAssign}{DyadicOperator}
Source level binary operator ``\code{<<=}''.

\ifcSortSection{RshiftAssign}{DyadicOperator}
Source level binary operator ``\code{>>=}''.

\ifcSortSection{Comma}{DyadicOperator}
Source level binary operator ``\code{,}''.

\ifcSortSection{Dot}{DyadicOperator}
Source level binary operator ``\code{.}''.

\ifcSortSection{Arrow}{DyadicOperator}
Source level binary operator ``\code{->}''.

\ifcSortSection{DotStar}{DyadicOperator}
Source level binary operator ``\code{.*}''.

\ifcSortSection{ArrowStar}{DyadicOperator}
Source level binary operator ``\code{->*}''.

\ifcSortSection{Curry}{DyadicOperator}
Abstract machine operation binding the first parameter of a function taking at least one argument.

\ifcSortSection{Apply}{DyadicOperator}
Abstract machine operation applying a callable to an argument list (conceptually a tuple).

\ifcSortSection{Index}{DyadicOperator}
Source level binary operator ``\code{[]}'' as in ``\code{x[y]}''.

\ifcSortSection{DefaultAt}{DyadicOperator}
Abstraction machine operation corresponding to default construction of an object at a given address, e.g. ``\code{new(p) T}''.

\ifcSortSection{New}{DyadicOperator}
Abstract machine operation corresponding to allocating appropriate storage and constructing an object of a given type 
and with a given initializer, e.g. ``\code{new T(x)}''.

\ifcSortSection{NewArray}{DyadicOperator}
Abstract machine operation corresponding to allocating appropriate storage and default constructing an array of a given element type and length, 
e.g. ``\code{new T[n]}''. 

\ifcSortSection{Destruct}{DyadicOperator}
Abstract machine operation corresponding to the explicit call of a destructor for an object, e.g. ``\code{x.~T()}''.
See also \sortref{DestructAt}{DyadicOperator}.

\ifcSortSection{DestructAt}{DyadicOperator}
Abstract machine operation corresponding to the explicit call of a destructor through a pointer, e.g. ``\code{p->~T()}''.
See also \sortref{Destruct}{DyadicOperator}.

\ifcSortSection{Cleanup}{DyadicOperator}
Abstract machine operation evaluating the first operand, then running the second operand as a cleanup (object destruction).

\ifcSortSection{Qualification}{DyadicOperator}
Abstract machine operation corresponding to implicit cv-qualification of the type of the expression, 
e.g. as in from ``\code{T}'' to ``\code{const T}''.

\ifcSortSection{Promote}{DyadicOperator}
Abstract machine operation corresponding to integral or floating point promotion at the source level.
See also \sortref{Demote}{DyadicOperator}.

\ifcSortSection{Demote}{DyadicOperator}
Abstract machine operation corresponding to the inverse of an integral or floating point promotion at the source level.
See also \sortref{Promote}{DyadicOperator}.

\ifcSortSection{Coerce}{DyadicOperator}
Abstract machine operation corresponding to an implicit conversion at the source level that is neither 
a promotion (\sortref{Promote}{DyadicOperator}) nor a demotion (\sortref{Demote}{DyadicOperator}).

\ifcSortSection{Rewrite}{DyadicOperator}
Abstract machine operation where the semantics of the first operand (source-level construct) is defined by that of the second operand.

\ifcSortSection{Bless}{DyadicOperator}
Abstract machine operation proclaiming a valid object of given type (second operand) at a given address (first operand).  
Note that this operation is not a placement-new operator (which would entail running a constructor).

\ifcSortSection{Cast}{DyadicOperator}
A C-style cast operation, e.g. ``\code{T)x}''

\ifcSortSection{ExplicitConversion}{DyadicOperator}
A functional cast notation, e.g. ``\code{T(x)}''.

\ifcSortSection{ReinterpretCast}{DyadicOperator}
Source level operator ``\code{reinterpret\_cast}''.

\ifcSortSection{StaticCast}{DyadicOperator}
Source level operator ``\code{static\_cast}''.

\ifcSortSection{ConstCast}{DyadicOperator}
Source level operator ``\code{const\_cast}''.

\ifcSortSection{DynamicCast}{DyadicOperator}
Source level operator ``\code{dynamic\_cast}''.

\ifcSortSection{Narrow}{DyadicOperator}
Abstract machine operation corresponding to the runtime-checked conversion of a pointer of type ``\code{B*}'' 
(or reference of type ``\code{B\&}'') to a pointer of type ``\code{D*}'' (or reference of type ``\code{D\&}'')
where the class ``\code{D}'' is a derived class of ``\code{B}''.

\ifcSortSection{Widen}{DyadicOperator}
Abstract machine operation corresponding to the implicit conversion of a pointer of type ``\code{D*}'' (or 
reference of type ``\code{D\&}'') to a pointer of type ``\code{B*}'' (or a reference of type ``\code{B&}''),
where the class ``\code{D}'' is a derived class of ``\code{B}''.

\ifcSortSection{Pretend}{DyadicOperator}
Abstract machine operation generalizing \code{bitcat} and \code{rinterpret\_cast}.

\ifcSortSection{Closure}{DyadicOperator}
Abstract machine operation pairing a function pointer (the second operand) and an environment of captured variables (the first operand) 
for proper execution, as in lambda expressions.

\ifcSortSection{ZeroInitialize}{DyadicOperator}
Abstract machine operation performing zero-initialization of an object or a subobject.
See also \sortref{ClearStorage}{DyadicOperator}.

\ifcSortSection{ClearStorage}{DyadicOperator}
Abstract machine operation clearing (i.e. setting all bytes to value $0$) a storage span.
See also \sortref{ZeroInitialize}{DyadicOperator}.

\ifcSortSection{Select}{DyadicOperator}
Use of the source-level scope resolution operator ``\code{::}''.
The first operand designates the scope, and the second operand designates the member to select.

\ifcSortSection{Msvc}{DyadicOperator}
This is a marker, not an actual operator. Dyadic operators with 
value greater that this are MSVC extensions.

\ifcSortSection{MsvcTryCast}{DyadicOperator}
Abstract machine operation corresponding to the WinRT extension operation of ``\emph{try cast}''.

\ifcSortSection{MsvcCurry}{DyadicOperator}
Abstract machine operation corresponding to the MSVC extension of bound member function, 
e.g. ``\code{this->fun}'' where \code{fun} is a non-static member function.  
The first operand designates the object,
and the second operand designates the non-static member function.
See also \sortref{MsvcVirtualCurry}{DyadicOperator}.

\ifcSortSection{MsvcVirtualCurry}{DyadicOperator}
Abstract machine operation with similar semantics as that of \valueTag{DyadicOperator::MsvcCurry}, except
the resulting callable requires a dynamic dispatch.

\ifcSortSection{MsvcAlign}{DyadicOperator}
Abstract machine operation of aligning a pointer to an adequate storage address boundary.

\ifcSortSection{MsvcBitSpan}{DyadicOperator}
Abstract machine operation describing the span of a bitfield.
The first operand describes the offset (in number of bits) from the start of the storage hosting the bitfield.
The second operand describes the number of bits spanned by the bitfield.

\ifcSortSection{MsvcBitfieldAccess}{DyadicOperator}
Abstract machine operation describing access to a bitfield.
The first operand designates the start of the storage hosting the bitfield.
The second operand describes the span (\sortref{MsvcBitSpan}{DyadicOperator}) of the bitfield.

\ifcSortSection{MsvcObscureBitfieldAccess}{DyadicOperator}
Abstract machine operation describing access to a bitfield.  
See also \sortref{MsvcBitfieldAccess}{DyadicOperator}.

\ifcSortSection{MsvcInitialize}{DyadicOperator}
Abstract machine operation describing the initialization of an object.
The first operand designates the storage to initialize.
The second operand designates the initializer or the function to run to perform initialization (in the case constructor).

\ifcSortSection{MsvcBuiltinOffsetOf}{DyadicOperator}
Source level ``\code{__builtin_offsetof}'' operator (\sortref{MsvcBuiltinOffsetOf}{SourceKeyword}).

\ifcSortSection{MsvcIsBaseOf}{DyadicOperator}
Source level ``\code{__is_base_of}'' operator (\sortref{MsvcIsBaseOf}{SourceKeyword}).

\ifcSortSection{MsvcIsConvertibleTo}{DyadicOperator}
Source level ``\code{__is_convertible_to}'' operator (\sortref{MsvcIsConvertibleTo}{SourceKeyword}).

\ifcSortSection{MsvcIsTriviallyAssignable}{DyadicOperator}
Source level ``\code{__is_trivially_assignable}'' operator (\sortref{MsvcIsTriviallyAssignable}{SourceKeyword}).

\ifcSortSection{MsvcIsNothrowAssignable}{DyadicOperator}
Source level ``\code{__is_nothrow_assignable}'' operator (\sortref{MsvcIsNothrowAssignable}{SourceKeyword}).

\ifcSortSection{MsvcIsAssignable}{DyadicOperator}
Source level ``\code{__is_assignable}'' operator (\sortref{MsvcIsAssignable}{SourceKeyword}).

\ifcSortSection{MsvcIsAssignableNocheck}{DyadicOperator}
Source level ``\code{__is_assignable_no_precondition_check}'' operator (\sortref{MsvcIsAssignableNocheck}{SourceKeyword})

\ifcSortSection{MsvcBuiltinBitCast}{DyadicOperator}
Source level ``\code{__builtin_bit_cast}'' operator (\sortref{MsvcBuiltinBitCast}{SourceKeyword}).

\ifcSortSection{MsvcBuiltinIsLayoutCompatible}{DyadicOperator}
Source level ``\code{__builtin_is_layout_compatible}'' operator (\sortref{MsvcBuiltinIsLayoutCompatible}{SourceKeyword}).

\ifcSortSection{MsvcBuiltinIsPointerInterconvertibleBaseOf}{DyadicOperator}
Source level ``\code{__builtin_is_pointer_interconvertible_base_of}'' operator (\sortref{MsvcBuiltinIsPointerInterconvertibleBaseOf}{SourceKeyword}).

\ifcSortSection{MsvcBuiltinIsPointerInterconvertibleWithClass}{DyadicOperator}
Source level ``\code{__builtin_is_pointer_interconvertible_with_class}'' operator (\sortref{MsvcBuiltinIsPointerInterconvertibleWithClass}{SourceKeyword}).

\ifcSortSection{MsvcBuiltinIsCorrespondingMember}{DyadicOperator}
Source level ``\code{__builtin_is_corresponding_member}'' operator (\sortref{MsvcBuiltinIsCorrespondingMember}{SourceKeyword}).

\ifcSortSection{MsvcIntrinsic}{DyadicOperator}
Abstract machine operation corresponding to the call of an MSVC intrinsic operator of function.
The first operand is an integer constant describing the intrinsic; the second operand is the argument list.
See also \sortref{Call}{ExprSort}.

\ifcSortSection{MsvcSaturatedArithmetic}{DyadicOpererator}
An MSVC intrinsic for an abstract machine saturated arithemtic operation. 
If the arithmetic computation described by the first operand overflows, 
then the result is the saturated value indicated by the second operand.

\ifcSortSection{MsvcBuiltinAllocationAnnotation}{DyadicOperator}
An MSVC intrinsic used to express the type of a runtime-allocated object at a given address.
The first argument is the expression designating the allocated address; the second argument designates the type of the object allocated at that address.

\subsection{Triadic operators}
\label{sec:ifc:OperatorSort:Triadic}

A sort value \valueTag{OperatorSort::Triadic} indicates a triadic operator -- 
an operator accepting three arguments.  The
value of the \field{index} is to be interpreted as a value of type 
\type{TriadicOperator}, which is a set of $12$-bit values enumerated as follows.
%
\begin{Enumeration}{TriadicOperator}
	\enumerator{Unknown}
	\enumerator{Choice}
	\enumerator{ConstructAt}
	\enumerator{Initialize}

	\setcounter{enumi}{1023}
	\enumerator{Msvc}
	\setcounter{enumi}{4063}
	\enumerator{MsvcConfusion}
	\enumerator{MsvcConfusedPushState}
	\enumerator{MsvcConfusedChoice}
\end{Enumeration}

\ifcSortSection{Unknown}{TriadicOperator}
An invalid triadic operator.  This value should never be generated.

\ifcSortSection{Choice}{TriadicOperator}
Source-level ternary ``\code{?:}'' operator.

\ifcSortSection{ConstructAt}{TriadicOperator}
Source-level representation of ``\code{new(p) T(x)}'', where
\begin{itemize}
	\item the first operand is the placement \code{p}
	\item the second operand is the constructed type \code{T}
	\item the third operand is the initializing value \code{x}
\end{itemize}

\ifcSortSection{Initialize}{TriadicOperator}

C++ abstract machine operation.

\ifcSortSection{Msvc}{TriadicOperator}
This is a marker, not an actual operator. Triadic operators with 
value greater that this are MSVC extensions.

\ifcSortSection{MsvcConfusion}{TriadicOperator}
This operator is no longer emitted in this version and up of the IFC.

\ifcSortSection{MsvcConfusedPushState}{TriadicOperator}
This is an MSVC-specific operator to represent a low-level cleanup action related to exception handling.
The three operands to this operator have the following meanings:
\begin{enumerate}
  \item the first operand designates a constructor call
  \item the second operand designates a destructor call
  \item the third operand designates an integer constant expression that is
   a $64$-bit integer bitmask describing various semantic aspects of the cleanup action. 
\end{enumerate}

\note{This operator is scheduled for removal in future releases of the IFC.}

\subsection{Storage operators}
\label{sec:ifc:OperatorSort:Storage}

A sort value \valueTag{OperatorSort::Storage} indicates a storage 
allocation or deallocation operator.  The
value of the \field{index} is to be interpreted as a value of type 
\type{StorageOperator}, which is a set of $12$-bit values enumerated as follows.
%
\begin{Enumeration}{StorageOperator}
	\enumerator{Unknown}
	\enumerator{AllocateSingle}
	\enumerator{AllocateArray}
	\enumerator{DeallocateSingle}
	\enumerator{DeallocateArray}

	\setcounter{enumi}{2013}
	\enumerator{Msvc}
\end{Enumeration}

\ifcSortSection{Unknown}{StorageOperator}
An invalid triadic operator.  This value should never be generated.

\ifcSortSection{AllocateSingle}{StorageOperator}
Source-level ``\code{new}'' operator.

\ifcSortSection{AllocateArray}{StorageOperator}
Source-level ``\code{new[]}'' operator.

\ifcSortSection{DeallocateSingle}{StorageOperator}
Source-level ``\code{delete}'' operator.

\ifcSortSection{DeallocateArray}{StorageOperator}
Source-level ``\code{delete[]}'' operator.

\ifcSortSection{Msvc}{StorageOperator}
This is a marker, not an actual operator. Triadic operators with 
value greater that this are MSVC extensions.

\subsection{Variadic operators}
\label{sec:ifc:OperatorSort:Variadic}

A sort value \valueTag{OperatorSort::Variadic} indicates a variadic operator -- 
an operator accepting any number of arguments.  The
value of the \field{index} is to be interpreted as a value of type 
\type{VariadicOperator}, which is a set of $12$-bit values enumerated as follows.
%
\begin{Enumeration}{VariadicOperator}
	\enumerator{Unknown}
	\enumerator{Collection}
	\enumerator{Sequence}

	\setcounter{enumi}{1023}
	\enumerator{Msvc}
	\enumerator{MsvcHasTrivialConstructor}
	\enumerator{MsvcIsConstructible}
	\enumerator{MsvcIsNothrowConstructible}
	\enumerator{MsvcIsTriviallyConstructible}
\end{Enumeration}


\ifcSortSection{Unknown}{VariadicOperator}
An invalid triadic operator.  This value should never be generated.

\ifcSortSection{Collection}{VariadicOperator}

C++ abstract machine.  Collection of expressions, with no specific order of evaluation. 

\ifcSortSection{Sequence}{VariadicOperator}

C++ abstract machine.  Like \valueTag{VariadicOperator::Collection} 
(\sortref{Collection}{VariadicOperator}) but with a defined left-to-right 
order of evaluation.

\ifcSortSection{Msvc}{VariadicOperator}
This is a marker, not an actual operator. Triadic operators with 
value greater that this are MSVC extensions.

\ifcSortSection{MsvcHasTrivialConstructor}{VariadicOperator}
Source-level ``\code{__has_trivial_constructor}'' operator (\sortref{MsvcHasTrivialConstructor}{SourceKeyword}).

\ifcSortSection{MsvcIsConstructible}{VariadicOperator}
Source-level ``\code{__is_contructible}'' operator (\sortref{MsvcIsConstructible}{SourceKeyword}).

\ifcSortSection{MsvcIsNothrowConstructible}{VariadicOperator}
Source-level ``\code{__is_nothrow_contructible}'' operator (\sortref{MsvcIsNothrowConstructible}{SourceKeyword}).

\ifcSortSection{MsvcIsTriviallyConstructible}{VariadicOperator}
Source-level ``\code{__is_trivially_constructible}'' operator 
(\sortref{MsvcIsTriviallyConstructible}{SourceKeyword}).






















